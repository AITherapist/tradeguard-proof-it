import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.57.2";
import { PDFDocument, rgb, StandardFonts } from "https://esm.sh/pdf-lib@1.17.1";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

const logStep = (step: string, details?: any) => {
  const detailsStr = details ? ` - ${JSON.stringify(details)}` : '';
  console.log(`[GENERATE-PDF-REPORT] ${step}${detailsStr}`);
};

// Generate professional PDF report using pdf-lib
async function generatePDFReport(jobData: any, evidenceItems: any[], profile: any): Promise<Uint8Array> {
  const pdfDoc = await PDFDocument.create();
  
  // Add fonts
  const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
  
  // Create first page
  const page = pdfDoc.addPage([595.28, 841.89]); // A4 size
  const { width, height } = page.getSize();
  
  // Colors
  const primaryColor = rgb(0.12, 0.23, 0.55); // #1E3A8A
  const secondaryColor = rgb(0.4, 0.4, 0.4); // #666666
  const successColor = rgb(0.06, 0.73, 0.51); // #10B981
  const warningColor = rgb(0.96, 0.62, 0.04); // #F59E0B
  const dangerColor = rgb(0.94, 0.27, 0.27); // #EF4444
  
  let currentY = height - 50;
  
  // Header
  page.drawText('BLUHATCH', {
    x: 50,
    y: currentY,
    size: 24,
    font: boldFont,
    color: primaryColor,
  });
  
  currentY -= 30;
  
  // Report title
  page.drawText('TRADE PROTECTION REPORT', {
    x: 50,
    y: currentY,
    size: 18,
    font: boldFont,
    color: rgb(0, 0, 0),
  });
  
  currentY -= 20;
  
  // Report subtitle
  page.drawText('Legally Admissible Evidence Documentation', {
    x: 50,
    y: currentY,
    size: 12,
    font: font,
    color: secondaryColor,
  });
  
  currentY -= 40;
  
  // Report info box
  const reportId = `BH-${jobData.id.split('-')[0].toUpperCase()}`;
  const currentDate = new Date().toLocaleDateString('en-GB');
  const currentTime = new Date().toLocaleTimeString('en-GB');
  
  // Draw info box background
  page.drawRectangle({
    x: 45,
    y: currentY - 80,
    width: width - 90,
    height: 80,
    borderColor: primaryColor,
    borderWidth: 1,
  });
  
  // Report info content
  page.drawText(`Report ID: ${reportId}`, {
    x: 55,
    y: currentY - 20,
    size: 10,
    font: boldFont,
    color: primaryColor,
  });
  
  page.drawText(`Generated: ${currentDate} at ${currentTime}`, {
    x: 55,
    y: currentY - 35,
    size: 10,
    font: font,
    color: rgb(0, 0, 0),
  });
  
  page.drawText(`Generated By: ${profile?.company_name || 'Professional Tradesperson'}`, {
    x: 55,
    y: currentY - 50,
    size: 10,
    font: font,
    color: rgb(0, 0, 0),
  });
  
  page.drawText(`Evidence Items: ${evidenceItems.length} items documented`, {
    x: 55,
    y: currentY - 65,
    size: 10,
    font: font,
    color: rgb(0, 0, 0),
  });
  
  currentY -= 100;
  
  // Protection status section
  const protectionStatus = jobData.protection_status;
  const protectionColor = protectionStatus >= 80 ? successColor : 
                         protectionStatus >= 60 ? warningColor : dangerColor;
  
  // Protection status background
  page.drawRectangle({
    x: 45,
    y: currentY - 60,
    width: width - 90,
    height: 60,
    color: protectionColor,
  });
  
  // Protection percentage
  page.drawText(`${protectionStatus}%`, {
    x: width / 2 - 30,
    y: currentY - 25,
    size: 24,
    font: boldFont,
    color: rgb(1, 1, 1),
  });
  
  page.drawText('PROTECTION COVERAGE', {
    x: width / 2 - 60,
    y: currentY - 45,
    size: 12,
    font: boldFont,
    color: rgb(1, 1, 1),
  });
  
  currentY -= 80;
  
  // Job details section
  page.drawText('JOB DETAILS', {
    x: 50,
    y: currentY,
    size: 14,
    font: boldFont,
    color: primaryColor,
  });
  
  currentY -= 30;
  
  // Job details grid
  const jobDetails = [
    ['Client Name:', jobData.client_name],
    ['Client Phone:', jobData.client_phone || 'Not provided'],
    ['Job Type:', jobData.job_type.replace('_', ' ').toUpperCase()],
    ['Contract Value:', jobData.contract_value ? 'Â£' + jobData.contract_value.toLocaleString() : 'Not specified'],
    ['Start Date:', jobData.start_date ? new Date(jobData.start_date).toLocaleDateString('en-GB') : 'Not specified'],
    ['Completion Date:', jobData.completion_date ? new Date(jobData.completion_date).toLocaleDateString('en-GB') : 'In progress'],
  ];
  
  for (let i = 0; i < jobDetails.length; i += 2) {
    const leftDetail = jobDetails[i];
    const rightDetail = jobDetails[i + 1];
    
    // Left column
    page.drawText(leftDetail[0], {
      x: 55,
      y: currentY,
      size: 10,
      font: boldFont,
      color: secondaryColor,
    });
    page.drawText(leftDetail[1], {
      x: 55,
      y: currentY - 15,
      size: 10,
      font: font,
      color: rgb(0, 0, 0),
    });
    
    // Right column
    if (rightDetail) {
      page.drawText(rightDetail[0], {
        x: 300,
        y: currentY,
        size: 10,
        font: boldFont,
        color: secondaryColor,
      });
      page.drawText(rightDetail[1], {
        x: 300,
        y: currentY - 15,
        size: 10,
        font: font,
        color: rgb(0, 0, 0),
      });
    }
    
    currentY -= 40;
  }
  
  // Client address
  page.drawText('Client Address:', {
    x: 55,
    y: currentY,
    size: 10,
    font: boldFont,
    color: secondaryColor,
  });
  page.drawText(jobData.client_address, {
    x: 55,
    y: currentY - 15,
    size: 10,
    font: font,
    color: rgb(0, 0, 0),
  });
  
  currentY -= 40;
  
  // Job description if available
  if (jobData.job_description) {
    page.drawText('Job Description:', {
      x: 55,
      y: currentY,
      size: 10,
      font: boldFont,
      color: secondaryColor,
    });
    
    // Split long descriptions into multiple lines
    const words = jobData.job_description.split(' ');
    let line = '';
    let lineY = currentY - 15;
    
    for (const word of words) {
      const testLine = line + (line ? ' ' : '') + word;
      if (testLine.length > 80) { // Approximate character limit per line
        page.drawText(line, {
          x: 55,
          y: lineY,
          size: 10,
          font: font,
          color: rgb(0, 0, 0),
        });
        line = word;
        lineY -= 15;
      } else {
        line = testLine;
      }
    }
    
    if (line) {
      page.drawText(line, {
        x: 55,
        y: lineY,
        size: 10,
        font: font,
        color: rgb(0, 0, 0),
      });
    }
    
    currentY = lineY - 30;
  }
  
  // Check if we need a new page for evidence
  if (currentY < 200) {
    const newPage = pdfDoc.addPage([595.28, 841.89]);
    currentY = newPage.getSize().height - 50;
  }
  
  // Evidence section
  page.drawText('EVIDENCE DOCUMENTATION', {
    x: 50,
    y: currentY,
    size: 14,
    font: boldFont,
    color: primaryColor,
  });
  
  currentY -= 30;
  
  // Group evidence by type
  const evidenceByType = evidenceItems.reduce((acc, item) => {
    if (!acc[item.evidence_type]) acc[item.evidence_type] = [];
    acc[item.evidence_type].push(item);
    return acc;
  }, {});
  
  const getEvidenceTypeLabel = (type: string) => {
    const labels: { [key: string]: string } = {
      'before': 'Before Work',
      'progress': 'Work in Progress', 
      'after': 'After Completion',
      'approval': 'Client Approval',
      'defect': 'Defect Documentation',
      'contract': 'Contract Evidence',
      'receipt': 'Receipt/Payment'
    };
    return labels[type] || type.charAt(0).toUpperCase() + type.slice(1);
  };
  
  // Add evidence items
  for (const [type, items] of Object.entries(evidenceByType)) {
    if (currentY < 100) {
      const newPage = pdfDoc.addPage([595.28, 841.89]);
      currentY = newPage.getSize().height - 50;
    }
    
    // Evidence type header
    page.drawRectangle({
      x: 45,
      y: currentY - 25,
      width: width - 90,
      height: 25,
      color: primaryColor,
    });
    
    page.drawText(`${getEvidenceTypeLabel(type)} Evidence (${(items as any[]).length} items)`, {
      x: 55,
      y: currentY - 15,
      size: 12,
      font: boldFont,
      color: rgb(1, 1, 1),
    });
    
    currentY -= 35;
    
    // Evidence items
    for (const item of items as any[]) {
      if (currentY < 80) {
        const newPage = pdfDoc.addPage([595.28, 841.89]);
        currentY = newPage.getSize().height - 50;
      }
      
      // Evidence item box
      page.drawRectangle({
        x: 45,
        y: currentY - 60,
        width: width - 90,
        height: 60,
        borderColor: rgb(0.8, 0.8, 0.8),
        borderWidth: 1,
      });
      
      // Evidence description
      page.drawText('Description:', {
        x: 55,
        y: currentY - 15,
        size: 9,
        font: boldFont,
        color: secondaryColor,
      });
      
      // Split description if too long
      const desc = item.description || 'No description provided';
      const descWords = desc.split(' ');
      let descLine = '';
      let descY = currentY - 30;
      
      for (const word of descWords) {
        const testLine = descLine + (descLine ? ' ' : '') + word;
        if (testLine.length > 70) {
          page.drawText(descLine, {
            x: 55,
            y: descY,
            size: 9,
            font: font,
            color: rgb(0, 0, 0),
          });
          descLine = word;
          descY -= 12;
        } else {
          descLine = testLine;
        }
      }
      
      if (descLine) {
        page.drawText(descLine, {
          x: 55,
          y: descY,
          size: 9,
          font: font,
          color: rgb(0, 0, 0),
        });
      }
      
      // Timestamp
      page.drawText(`Timestamp: ${new Date(item.created_at).toLocaleString('en-GB')}`, {
        x: 55,
        y: currentY - 45,
        size: 8,
        font: font,
        color: secondaryColor,
      });
      
      // File hash
      page.drawText(`Hash: ${item.file_hash.substring(0, 20)}...`, {
        x: 55,
        y: currentY - 55,
        size: 8,
        font: font,
        color: secondaryColor,
      });
      
      currentY -= 80;
    }
  }
  
  // Add disclaimer page if needed
  if (currentY < 200) {
    const disclaimerPage = pdfDoc.addPage([595.28, 841.89]);
    currentY = disclaimerPage.getSize().height - 50;
  }
  
  // Legal disclaimers
  page.drawText('LEGAL DISCLAIMERS', {
    x: 50,
    y: currentY,
    size: 14,
    font: boldFont,
    color: primaryColor,
  });
  
  currentY -= 30;
  
  const disclaimers = [
    'Evidence Disclaimer: Evidence must be captured truthfully and completely. Bluhatch does not alter or verify factual accuracy of descriptions or photos. Users are solely responsible for entering correct context.',
    'Report Disclaimer: This report was automatically generated using the Bluhatch platform. All descriptions and evidence are user-supplied. Bluhatch does not provide legal advice and cannot guarantee admissibility in every court or tribunal.',
    'Signature Disclaimer: Digital signatures represent the client\'s acknowledgement as entered at the time of capture. Users are responsible for ensuring authenticity of consent.',
    'Blockchain Verification: File integrity can be independently verified using the SHA-256 hashes and OpenTimestamps proofs provided. Visit opentimestamps.org for verification tools.'
  ];
  
  for (const disclaimer of disclaimers) {
    if (currentY < 50) {
      const newPage = pdfDoc.addPage([595.28, 841.89]);
      currentY = newPage.getSize().height - 50;
    }
    
    // Split disclaimer into multiple lines
    const words = disclaimer.split(' ');
    let line = '';
    let lineY = currentY;
    
    for (const word of words) {
      const testLine = line + (line ? ' ' : '') + word;
      if (testLine.length > 80) {
        page.drawText(line, {
          x: 50,
          y: lineY,
          size: 9,
          font: font,
          color: rgb(0, 0, 0),
        });
        line = word;
        lineY -= 12;
      } else {
        line = testLine;
      }
    }
    
    if (line) {
      page.drawText(line, {
        x: 50,
        y: lineY,
        size: 9,
        font: font,
        color: rgb(0, 0, 0),
      });
    }
    
    currentY = lineY - 30;
  }
  
  // Footer
  const footerY = 50;
  page.drawText('This report was generated by Bluhatch Trade Protection System', {
    x: 50,
    y: footerY,
    size: 8,
    font: font,
    color: secondaryColor,
  });
  
  page.drawText(`Report ID: ${reportId} | Generated: ${currentDate} at ${currentTime}`, {
    x: 50,
    y: footerY - 15,
    size: 8,
    font: font,
    color: secondaryColor,
  });
  
  return await pdfDoc.save();
}

serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  const supabaseClient = createClient(
    Deno.env.get("SUPABASE_URL") ?? "",
    Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "",
    { auth: { persistSession: false } }
  );

  try {
    logStep("PDF Report generation started");

    const authHeader = req.headers.get("Authorization");
    if (!authHeader) throw new Error("No authorization header provided");
    
    const token = authHeader.replace("Bearer ", "");
    const { data: userData, error: userError } = await supabaseClient.auth.getUser(token);
    if (userError) throw new Error(`Authentication error: ${userError.message}`);
    const user = userData.user;
    if (!user) throw new Error("User not authenticated");

    const { job_id } = await req.json();
    if (!job_id) {
      throw new Error("Missing job_id");
    }

    logStep("Request parsed", { job_id });

    // Get job data with ownership verification
    const { data: jobData, error: jobError } = await supabaseClient
      .from('jobs')
      .select('*')
      .eq('id', job_id)
      .eq('user_id', user.id)
      .single();

    if (jobError || !jobData) {
      throw new Error("Job not found or access denied");
    }

    // Get user profile
    const { data: profile } = await supabaseClient
      .from('profiles')
      .select('*')
      .eq('user_id', user.id)
      .single();

    // Get all evidence for this job
    const { data: evidenceItems, error: evidenceError } = await supabaseClient
      .from('evidence_items')
      .select('*')
      .eq('job_id', job_id)
      .order('created_at', { ascending: true });

    if (evidenceError) {
      throw new Error(`Failed to fetch evidence: ${evidenceError.message}`);
    }

    logStep("Data fetched", { 
      jobId: jobData.id, 
      evidenceCount: evidenceItems?.length || 0,
      protectionStatus: jobData.protection_status 
    });

    // Generate PDF report
    const pdfBytes = await generatePDFReport(jobData, evidenceItems || [], profile);
    logStep("PDF generated", { size: pdfBytes.length });

    // Generate filename
    const filename = `Bluhatch-Report-${jobData.client_name.replace(/\s+/g, '_')}-${new Date().toISOString().split('T')[0]}.pdf`;
    
    // Save report to reports table
    const { data: reportData, error: reportError } = await supabaseClient
      .from('reports')
      .insert({
        user_id: user.id,
        job_id: job_id,
        filename: filename,
        file_size: pdfBytes.length,
        report_type: 'pdf',
        status: 'generated',
        metadata: {
          evidence_count: evidenceItems?.length || 0,
          protection_status: jobData.protection_status,
          client_name: jobData.client_name,
          job_type: jobData.job_type,
          generated_at: new Date().toISOString(),
        }
      })
      .select()
      .single();

    if (reportError) {
      logStep("ERROR saving report to database", { error: reportError.message });
      throw new Error(`Failed to save report: ${reportError.message}`);
    }

    logStep("Report saved to database", { reportId: reportData.id });

    // Log audit trail
    await supabaseClient
      .from('audit_logs')
      .insert({
        user_id: user.id,
        job_id: job_id,
        action: 'pdf_report_generated',
        details: {
          report_id: reportData.id,
          evidence_count: evidenceItems?.length || 0,
          protection_status: jobData.protection_status,
          pdf_size: pdfBytes.length,
        },
        ip_address: req.headers.get('x-forwarded-for') || req.headers.get('x-real-ip'),
        user_agent: req.headers.get('user-agent'),
      });

    return new Response(JSON.stringify({ 
      success: true,
      pdf_bytes: Array.from(pdfBytes), // Convert Uint8Array to regular array for JSON
      filename: filename,
      report_id: reportData.id
    }), {
      headers: { 
        ...corsHeaders, 
        "Content-Type": "application/json"
      },
      status: 200,
    });

  } catch (error: any) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logStep("ERROR in generate-pdf-report", { message: errorMessage });
    return new Response(JSON.stringify({ error: errorMessage }), {
      headers: { ...corsHeaders, "Content-Type": "application/json" },
      status: 500,
    });
  }
});
